# 附录 B：如何阅读弹珠图？
当我们介绍Flux和Mono时，我们展示了一个“弹珠图”的例子。这些可以在整个 javadoc 中找到，以便以更直观的方式解释运算符的行为。

在本节中，我们将更深入地研究 Reactor 文档对这些弹珠图使用的约定。首先，让我们看看最常见的运算符模式是如何表示的。

一些运算符是实例方法：它们的输出是通过调用源Flux实例上的方法产生的（如Flux<T> output = source.fluxOperator()）：

普通运营商
其他运算符是静态方法。他们仍然可以将源作为输入参数，例如在Flux<T> output = Flux.merge(sourceFlux1, sourcePublisher2). 这些表示如下：

静态运算符
请注意，有时我们根据运算符的输入表示多个变体或行为，在这种情况下，只有一个运算符“框”，但源和输出变体是分开的，如下所示：

具有两个输入示例的运算符
这些是基本情况，但一些操作符显示稍微更高级的模式。

例如，ParallelFlux创建多个 rails 以便它们具有多个 output Flux。它们依次表示，如下图所示：

并行运算符
窗口运算符产生一个Flux<Flux<T>>：主要Flux通知每个窗口打开，而内部Flux表示窗口内容和终止。Windows 表示为 main 的分支，Flux如下图所示：

窗口运算符的输出
有时，运营商将“同伴发布者”作为输入（aFlux或Mono任意 Reactive Stream Publisher）。这样的同伴发布者帮助定制运营商的行为，其将使用同伴的一些信号作为其自身内部行为的触发器。它们如下图所示：

有同伴发布者的操作员
现在我们已经了解了最常见的运算符模式，让我们展示Fluxor中可能发生的所有不同信号、事件和元素的图形表示Mono：

所有类型的信号和事件
最后，以同样的方式，我们有副作用的图形表示，它与 Reactive Stream 信号一起出现：

副作用：doOn* 处理程序的表示
副作用：在图中

建议编辑到“如何阅读弹珠图？ ”